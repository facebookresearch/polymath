# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

from typing import Optional

from agent.symex.unique import UNIQUE

from libcst import (
    AnnAssign,
    BaseAssignTargetExpression,
    BaseExpression,
    ClassDef,
    CSTVisitor,
    Name,
    Subscript,
)
from libcst.metadata.type_inference_provider import TypeInferenceProvider


# The "Universe" class is a singleton, no need to pass its properties an instance parameter.
_UNIVERSE_CLASS_NAME: str = "Universe"

# Placeholder type to use for class type objects in SMT.
_SMT_CLASS_TYPE: str = "Int"

# Maps Python types to SMT types.
_PYTHON_TO_SMT_TYPE: dict[str, str] = {
    "bool": "Bool",
    "int": "Int",
    "float": "Real",
    "str": "String",
}


class AttributeUniqueInfo:
    """
    Metadata derived from `Unique[T]` annotations. This is used to generate
    uniqueness constraints over `universe` attributes.
    """

    def __init__(self, name: str, python_class_name: str, smt_type: str) -> None:
        self.name: str = name
        self.python_class_name: str = python_class_name
        self.smt_type: str = smt_type


class FieldTypeInfo:
    """
    Type information about fields in Python classes generated by the model.
    """

    def __init__(self) -> None:
        self.is_list: bool = False
        self.is_unique: bool = False
        self.name: str = ""
        self.python_type: str = ""
        self.smt_type: str = ""


class LogicPySMTDataStructureGenerator(CSTVisitor):
    """
    Converts LogicPy data structures to a equivalent SMT functions.
    """

    def __init__(self) -> None:
        self.ancestors_per_class: dict[str, set[str]] = {}
        self.smt_attributes: set[str] = set()
        self.smt_harness: str = ""
        self.__current_class = ""
        self.__current_type_info = FieldTypeInfo()
        self.__is_in_class: bool = False
        self.__is_in_universe_class: bool = False
        self.__unique_attributes: dict[str, list[AttributeUniqueInfo]] = {}

    def leave_AnnAssign(self, original_node: AnnAssign) -> None:
        if self.__is_in_class:
            target: BaseAssignTargetExpression = original_node.target
            if isinstance(target, Name):
                field_name: str = target.value
                smt_attribute_name: str = self.__get_smt_attribute_name_in_class(
                    self.__current_class, field_name
                )
                self.smt_attributes.add(smt_attribute_name)
                if self.__current_type_info.is_list:
                    self.smt_harness += f"(declare-fun {smt_attribute_name}_backing ("
                    if not self.__is_in_universe_class:
                        self.smt_harness += "Int "
                    self.smt_harness += f"Int) {self.__current_type_info.smt_type})\n"

                    self.smt_harness += f"(declare-fun {smt_attribute_name}_size ("
                    if not self.__is_in_universe_class:
                        self.smt_harness += "Int"
                    self.smt_harness += ") Int)\n"

                    self.smt_harness += f"(define-fun {smt_attribute_name} ("
                    if not self.__is_in_universe_class:
                        self.smt_harness += "(this Int) "
                    self.smt_harness += f"(index Int)) {self.__current_type_info.smt_type} ({smt_attribute_name}_backing "
                    if not self.__is_in_universe_class:
                        self.smt_harness += f"this "
                    self.smt_harness += f"(ite (and (>= index 0) (< index "
                    if self.__is_in_universe_class:
                        self.smt_harness += f"{smt_attribute_name}_size"
                    else:
                        self.smt_harness += f"({smt_attribute_name}_size this)"
                    self.smt_harness += ")) index 0)))\n"

                    if self.__is_in_universe_class:
                        attributes: list[AttributeUniqueInfo] = (
                            self.__unique_attributes.get(
                                self.__current_type_info.python_type, []
                            )
                        )
                        for attribute in attributes:
                            self.smt_harness += f"(declare-fun {smt_attribute_name}_by_{attribute.name} ({attribute.smt_type}) Int)\n"
                            smt_var_name: str = (
                                self.__current_type_info.python_type.lower()
                            )
                            self.smt_harness += f"""(assert
  (forall
    (({smt_var_name}_index Int))
    (let
      (({smt_var_name} ({smt_attribute_name} {smt_var_name}_index)))
      (=
        {smt_var_name}
        ({smt_attribute_name}_by_{attribute.name} ({self.__get_smt_attribute_name_in_class(attribute.python_class_name, attribute.name)} {smt_var_name}))
      )
    )
  )
)
"""

                    self.__current_type_info.is_list = False
                else:
                    self.smt_harness += f"(declare-fun {smt_attribute_name} ("
                    if not self.__is_in_universe_class:
                        self.smt_harness += "Int"
                    self.smt_harness += f") {self.__current_type_info.smt_type})\n"
                    if self.__current_type_info.is_unique:
                        unique_attributes: list[AttributeUniqueInfo] = (
                            self.__unique_attributes.setdefault(
                                self.__current_class, []
                            )
                        )
                        unique_attributes.append(
                            AttributeUniqueInfo(
                                field_name,
                                self.__current_class,
                                self.__current_type_info.smt_type,
                            )
                        )
                        self.__current_type_info.is_unique = False

    def visit_ClassDef(self, node: ClassDef) -> Optional[bool]:
        name: str = node.name.value
        self.__current_class = name
        if name == UNIQUE:
            return False

        bases: set[str] = self.ancestors_per_class.setdefault(name, set())
        for base in node.bases:
            value: BaseExpression = base.value
            if isinstance(value, Name):
                bases.add(value.value)

        self.__is_in_class = True
        self.__is_in_universe_class = self.__current_class == _UNIVERSE_CLASS_NAME
        self.smt_harness += f"; {self.__current_class}\n"

    def leave_ClassDef(self, original_node: ClassDef) -> None:
        if self.__current_class == UNIQUE:
            return

        self.smt_harness += "\n"
        self.__current_class = ""
        self.__is_in_class = False

    def visit_Name(self, node: Name) -> Optional[bool]:
        name: str = node.value
        self.__current_type_info.python_type = name
        self.__current_type_info.smt_type = (
            _PYTHON_TO_SMT_TYPE.get(name) or _SMT_CLASS_TYPE
        )

    def visit_Subscript(self, node: Subscript) -> Optional[bool]:
        if self.__is_in_class:
            value: BaseExpression = node.value
            if isinstance(value, Name):
                name: str = value.value
                match name:
                    case "list":
                        self.__current_type_info.is_list = True
                    case "Unique":
                        self.__current_type_info.is_unique = True

    def __get_smt_attribute_name_in_class(self, class_name: str, attr: str):
        """
        Formats the SMT name for attributes in classes mapped to a function
        name.

        Args:
            class_name (str): Python class name containing the attribute.
            attr (str): Name of the attribute.
        Returns:
            SMT function name to use to model the attribute.
        """
        return f"__attribute_{class_name}_{attr}"
